
/**
 * This template file was generated by dynaTrace client.
 * The dynaTrace community portal can be found here: http://community.compuwareapm.com/
 * For information how to publish a plugin please visit http://community.compuwareapm.com/plugins/contribute/
 **/

package com.dynatrace.diagnostics.plugin;

import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Collectors;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathFactory;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

import com.dynatrace.diagnostics.pdk.Monitor;
import com.dynatrace.diagnostics.pdk.MonitorEnvironment;
import com.dynatrace.diagnostics.pdk.MonitorMeasure;
import com.dynatrace.diagnostics.pdk.Plugin;
import com.dynatrace.diagnostics.pdk.Status;

public class IPlanetMonitor implements Monitor {

	private static final Logger log = Logger.getLogger(IPlanetMonitor.class.getName());
	private static final String DIVISION = "/";
	private static final String SUBTRACTION = "-";
	private static final String MULTIPLICATION = "*";
	private static final String ADDITION = "+";

	// initialize config variables
	private String firstMeasure;
	
	// AG Added - 14/12/2016
	private boolean firstMeasureIsStaticBool = false;
	private String secondMeasure;
	// AG Added - 14/12/2016
	private boolean secondMeasureIsStaticBool = false;
	
	private String operation;
	// The type of aggregation to apply
	private Map<String, String> aggregationMap;

	/**
	 * The restAPI is the variable allowing access to the data displayed in
	 * dashboards
	 */
	private ServerRestAPI restAPI;

	HostnameVerifier defaultVerifier = HttpsURLConnection.getDefaultHostnameVerifier();
	XPath xpath = XPathFactory.newInstance().newXPath();
	private Document doc;

	/**
	 * Initializes the Plugin. This method is called in the following cases:
	 * <ul>
	 * <li>before <tt>execute</tt> is called the first time for this scheduled
	 * Plugin</li>
	 * <li>before the next <tt>execute</tt> if <tt>teardown</tt> was called
	 * after the last execution</li>
	 * </ul>
	 * <p>
	 * If the returned status is <tt>null</tt> or the status code is a
	 * non-success code then {@link Plugin#teardown() teardown()} will be called
	 * next.
	 * <p>
	 * Resources like sockets or files can be opened in this method.
	 * 
	 * @param env
	 *            the configured <tt>MonitorEnvironment</tt> for this Plugin;
	 *            contains subscribed measures, but <b>measurements will be
	 *            discarded</b>
	 * @see Plugin#teardown()
	 * @return a <tt>Status</tt> object that describes the result of the method
	 *         call
	 */

	@Override
	public Status setup(MonitorEnvironment env) throws Exception {
		Status status = new Status(Status.StatusCode.Success);
		// check plugin environment configuration parameter values
		if (env == null || env.getHost() == null) {
			status.setStatusCode(Status.StatusCode.ErrorInternalConfigurationProblem);
			status.setShortMessage("Environment was not properly initialized. env.host must not be null.");
			status.setMessage("Environment was not properly initialized. env.host must not be null.");
			Exception e = new IllegalArgumentException(
					"Environment was not properly initialized. env.host must not be null.");
			status.setException(e);
			log.log(Level.SEVERE, status.getMessage(), e);
			return status;
		}
		restAPI = new ServerRestAPI(env.getConfigString("dtServer"), env.getConfigString("username"),
				env.getConfigPassword("password"));
		operation = env.getConfigString("operation");
		// AG Added 14/12/2016
		firstMeasureIsStaticBool = env.getConfigBoolean("first_measure_static_bool");
		logFine("First Measure Bool:" + firstMeasureIsStaticBool);
		firstMeasure = env.getConfigString("firstMeasure");
		
		secondMeasureIsStaticBool = env.getConfigBoolean("second_measure_static_bool");
		logFine("Second Measure Bool:" + secondMeasureIsStaticBool);
		secondMeasure = env.getConfigString("secondMeasure");
		
		aggregationMap = new HashMap<String, String>();
		aggregationMap.put("Minimum", "min");
		aggregationMap.put("Maximum", "max");
		aggregationMap.put("Sum", "sum");
		aggregationMap.put("Average", "avg");
		aggregationMap.put("Count", "count");

		Collection<MonitorMeasure> measures = env.getMonitorMeasures("RangeGroup", "Range");
		for (MonitorMeasure measure : measures) {
			measure.setValue(0);
		}
		return status;
	}

	@Override
	public Status execute(MonitorEnvironment env) throws Exception {
		Status status = new Status();
		logFine("Begin Plugin Execution");

		try {

			TrustSSL.trustAllCerts();

			try {
			doc = restAPI.getDashboard(env.getConfigString("dashboardName"));
			NodeList listDataRows = doc.getElementsByTagName("measure");
			List<Element> measureList = new ArrayList<Element>();
			Set<String> aggregationList = new HashSet<String>();
			List<NodeList> measurementList = Arrays.asList();
			String aggregation = null;
			String aggregationType = null;
			double result = 0;

			for (int i = 0; i < listDataRows.getLength(); i++) {
				Element measure = (Element) listDataRows.item(i);
				String measurename = measure.getAttributes().getNamedItem("measure").getNodeValue();
				aggregation = measure.getAttributes().getNamedItem("aggregation").getNodeValue();
				if ((!firstMeasureIsStaticBool && measurename.contains(firstMeasure)) || (!secondMeasureIsStaticBool && measurename.contains(secondMeasure)))
				{
					logFine("Adding: " + measurename + " because it's not static");
					measureList.add(measure);
					aggregationList.add(aggregationMap.get(aggregation));
				}
				/*
				 * if ((measurename.contains(secondMeasure) || measurename.contains(firstMeasure))&& measureList.size() < 2) {
				 *	measureList.add(measure);
				 *	aggregationList.add(aggregationMap.get(aggregation));
				 *
				 * }
				 */
			}
			// Assign the aggregation type
			aggregationType = aggregationList.iterator().next();
			// Only return the last item in the measurements
			measurementList = measureList.stream().map(el -> el.getElementsByTagName("measurement")).collect(Collectors.toList());

			Double measureOneValue = null;
			Double measureTwoValue = null;
			Long timestamp1 = null;
			Long timestamp2 = null;
			
			if (firstMeasureIsStaticBool) // static measure. Parse it.
			{
				measureOneValue = Double.parseDouble(firstMeasure);
				timestamp1 = System.currentTimeMillis();
				logFine("Static Measure One Value: " + measureOneValue);
			}
			else // non-static. Get from XML
			{
				
				Element measureOneElement = (Element) measurementList.get(0).item(measurementList.get(0).getLength() - 1);
				if (measureOneElement == null) measureOneValue = Double.valueOf(0); // If dashboard has no measurements. Protect against null values.
				else measureOneValue = Double.parseDouble(measureOneElement.getAttributes().getNamedItem(aggregationType).getNodeValue());
				timestamp1 = Long.parseLong(measureOneElement.getAttributes().getNamedItem("timestamp").getNodeValue());
				logFine("Non static measure one: " + measureOneValue);
			}
			if (secondMeasureIsStaticBool) // static measure. Parse it.
			{
				measureTwoValue = Double.parseDouble(secondMeasure);
				timestamp2 = System.currentTimeMillis();
				logFine("Static Measure Two Value: " + measureTwoValue);
			}
			else // non-static. Get from XML
			{
				Element measureTwoElement = (Element) measurementList.get(1).item(measurementList.get(1).getLength() - 1);
				if (measureTwoElement == null) measureTwoValue = Double.valueOf(0); // If dashboard has no measurements. Protect against null values.
				else measureTwoValue = Double.parseDouble(measureTwoElement.getAttributes().getNamedItem(aggregationType).getNodeValue());
				
				timestamp2 = Long.parseLong(measureTwoElement.getAttributes().getNamedItem("timestamp").getNodeValue());
				logFine("Non static measure two: " + measureTwoValue);
			}

			/* 
			 * Not sure what this is doing? AG.
			 * Temporarily wrap in boolean condition which ignores when either measure is static. 
			 */
			/*
			 * Does not allow static values removing to allow use. KK.
			 * Commenting until use is known
			if ((timestamp1.longValue() < timestamp2.longValue()) && (firstMeasureIsStaticBool || secondMeasureIsStaticBool)) {
				result = measureOneValue.doubleValue();
			}
			else
			{
			*/				
				switch (operation) {
				case ADDITION:
					result = Math.abs(measureOneValue + measureTwoValue);
					logFine("Addition Result: " + result);
					break;

				case MULTIPLICATION:
					result = Math.abs(measureOneValue * measureTwoValue);
					logFine("Multiplication Result: " + result);
					break;

				case DIVISION:
					// Protect against division by zero errors.
					if (measureTwoValue == 0)
					{
						logSevere("Division by Zero error.");
						result = -1;
					}
					else
					{
						result = Math.abs(measureOneValue / measureTwoValue);
					}
					logFine("Division Result: " + result);
					break;

				case SUBTRACTION:
					result = Math.abs(measureOneValue - measureTwoValue);
					logFine("Subtraction Result: " + result);
					break;
				default:
					break;
				}
			//}

			Collection<MonitorMeasure> monitorMeasures = env.getMonitorMeasures("ResultGroup", "result");
			for (MonitorMeasure measure : monitorMeasures) {
				measure.setValue(result);
			}

			//status.setMessage("Aggregation: " + aggregationType + "\nNode 1 value: " + measureOneElement.getAttributes().getNamedItem(aggregationType).getNodeValue() + "\nNode 2 Value: " + measureTwoElement.getAttributes().getNamedItem(aggregationType).getNodeValue());
			// AG Added - 14/12/2016
			status.setMessage("Aggregation: " + aggregationType + "\nNode 1 value: " + measureOneValue + "\nNode 2 Value: " + measureTwoValue);

			} catch (Throwable e) {
				logFine("Issue with REST API Call");
			    return status;
			}
			HttpsURLConnection.setDefaultHostnameVerifier(defaultVerifier);
			//logInfo("WTF");
		} catch (Exception ce) {
			status.setException(ce);
			status.setStatusCode(Status.StatusCode.PartialSuccess);
			status.setShortMessage(ce == null ? "" : ce.getClass().getSimpleName());
			log.log(Level.SEVERE, status.getMessage(), ce);
		}

		return status;
	}

	/**
	 * Shuts the Plugin down and frees resources. This method is called in the
	 * following cases:
	 * <ul>
	 * <li>the <tt>setup</tt> method failed</li>
	 * <li>the Plugin configuration has changed</li>
	 * <li>the execution duration of the Plugin exceeded the schedule timeout
	 * </li>
	 * <li>the schedule associated with this Plugin was removed</li>
	 * </ul>
	 *
	 * <p>
	 * The Plugin methods <tt>setup</tt>, <tt>execute</tt> and <tt>teardown</tt>
	 * are called on different threads, but they are called sequentially. This
	 * means that the execution of these methods does not overlap, they are
	 * executed one after the other.
	 *
	 * <p>
	 * Examples:
	 * <ul>
	 * <li><tt>setup</tt> (failed) -&gt; <tt>teardown</tt></li>
	 * <li><tt>execute</tt> starts, configuration changes, <tt>execute</tt> ends
	 * -&gt; <tt>teardown</tt><br>
	 * on next schedule interval: <tt>setup</tt> -&gt; <tt>execute</tt> ...</li>
	 * <li><tt>execute</tt> starts, execution duration timeout, <tt>execute</tt>
	 * stops -&gt; <tt>teardown</tt></li>
	 * <li><tt>execute</tt> starts, <tt>execute</tt> ends, schedule is removed
	 * -&gt; <tt>teardown</tt></li>
	 * </ul>
	 * Failed means that either an unhandled exception is thrown or the status
	 * returned by the method contains a non-success code.
	 *
	 *
	 * <p>
	 * All by the Plugin allocated resources should be freed in this method.
	 * Examples are opened sockets or files.
	 *
	 * @see Monitor#setup(MonitorEnvironment)
	 */
	@Override
	public void teardown(MonitorEnvironment env) throws Exception {
		HttpsURLConnection.setDefaultHostnameVerifier(defaultVerifier);
	}

	private void logSevere(String message) {
		if (log.isLoggable(Level.SEVERE)) {
			log.severe(message);
		}
	}

	private void logWarn(String message) {
		if (log.isLoggable(Level.WARNING)) {
			log.warning(message);
		}
	}

	private void logInfo(String message) {
		if (log.isLoggable(Level.INFO)) {
			log.info(message);
		}
	}

	private void logFine(String message) {
		if (log.isLoggable(Level.FINE)) {
			log.fine(message);
		}
	}
}

class TrustSSL {

	public static void trustAllCerts() throws Exception {
		// Create a trust manager that does not validate certificate chains
		TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {
			public java.security.cert.X509Certificate[] getAcceptedIssuers() {
				return null;
			}

			public void checkClientTrusted(X509Certificate[] certs, String authType) {
			}

			public void checkServerTrusted(X509Certificate[] certs, String authType) {
			}
		} };
		// Install the all-trusting trust manager
		final SSLContext sc = SSLContext.getInstance("SSL");
		sc.init(null, trustAllCerts, new java.security.SecureRandom());
		HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
		// Create all-trusting host name verifier
		HostnameVerifier allHostsValid = new HostnameVerifier() {
			public boolean verify(String hostname, SSLSession session) {
				return true;
			}
		};

		// Install the all-trusting host verifier
		HttpsURLConnection.setDefaultHostnameVerifier(allHostsValid);

	}
}
